\chapter{Конструкторский раздел}
\label{ch:design}


\section{Проектирование последовательного алгоритма}

Был разработан последовательный алгоритм поиска обратной матрицы, представленный на алгоритме~\ref{alg:inv_sq_matrix}.

\begin{small}
    \begin{algorithm}[H]
        \caption{Последовательный алгоритм поиска обратной матрицы}
        \label{alg:inv_sq_matrix}
        \begin{algorithmic}[1]
            \Procedure{invert\_sq\_matrix}{$matrixsize$, $matrix$, $inv$}
                \State Занулить матрицу $inv\_matrix$

                \For{$i$ от $0$ до $matrixsize-1$}
                    \State $inv[i][i] \gets 1$
                \EndFor

                \For{$i$  от $0$ до $matrixsize-1$}
                    \State $pivot \gets matrix[i][i]$

                    \State Умножить строку $matrix[i]$ на $1/pivot)$
                    \State Умножить строку $inv[i]$ на $1/pivot)$

                    \For{$j$ от $i+1$ до $matrixsize-1$}
                        \State $mul \gets matrix[j][i]$

                        \State Добавить к $matrix[j]$ строку $matrix[i]$, умноженную на $-mul$
                        \State Добавить к $inv[j]$ строку $inv[i]$, умноженную на $-mul$
                    \EndFor
                \EndFor

                \For{$i$ от $matrixsize-1$ до $1$ с шагом $-1$}
                    \For{$j$ от $0$ до $i-1$}
                        \State $mul \gets matrix[j][i]$
                        \State Добавить к $matrix[j]$ строку $matrix[i]$, умноженную на $-mul$
                        \State Добавить к $inv[j]$ строку $inv[i]$, умноженную на $-mul$
                    \EndFor
                \EndFor
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
\end{small}


\section{Проектирование параллельного алгоритма}

\subsection*{Анализ трудностей разработки}

Параллельный алгоритм для вычисления обратной матрицы методом Гаусса представляет собой интересный и важный пример применения распределённых вычислительных систем.
Его реализация может столкнуться с рядом проблем при комуникации между вычислительными узлами.
Рассмотрим основные сложности.

Одним из ключевых моментов является разбиение исходной матрицы между процессами.
Матрица должна быть разделена таким образом, чтобы каждый процесс получил свою часть работы, но при этом все процессы могли взаимодействовать друг с другом.
Если не учитывать особенности структуры матрицы и характер операций, то можно получить неравномерное распределение нагрузки между процессорами, что приведёт к увеличению временных затрат.

Метод Гаусса требует выполнения ряда последовательных шагов, которые включают обмен данными между процессорами.
Это приводит к необходимости частых коммуникационных операций, таких как передача строк или столбцов матрицы от одного процесса другому.
Частые коммуникации существенно замедляют выполнение программы, так как время передачи данных через сеть может оказаться значительно больше времени обработки самих данных.

Для корректного выполнения метода необходимо синхронизировать работу всех процессов после каждого шага алгоритма.
Это связано с тем, что результаты одной итерации используются в следующей.


\subsection*{Распределение данных между узлами}

Предлагается циклическая рассылка строк матрицы вычислительным узлам.


Существует несколько причин, почему строки матрицы следует отправлять циклически разным вычислительным узлам:


Предположим, у нас есть матрица размером NxN и P вычислительных узлов.
Мы можем разделить матрицу на P частей и отправить каждую часть соответствующему узлу. Например:


\begin{itemize}
    \item Узел 0 получит строки с номерами $0$, $P$, $2P$, ...
    \item Узел 1 получит строки с номерами 1, $P+1$, $2P+1$, ...
    \item И так далее до узла $P-1$, который получит строки $P-1$, $2P-1$, ...
\end{itemize}

Это гарантирует, что каждая строка будет обработана ровно одним узлом, и каждый узел получит равное количество строк для обработки.


Цикличная рассылка строк матрицы разным вычислительным узлам является эффективным способом обеспечения равномерной загрузки узлов, минимизации коммуникаций.
Данный подход широко используется в различных параллельных алгоритмах.


\subsection*{Алгоритм}

Был разработан распределенный алгоритм поиска обратной матрицы c учетом описанных выше замечаний.
Он представлен на алгоритме~\ref{alg:inv_pl_matrix}.


\begin{small}
    \begin{algorithm}[H]
        \caption{Распределенный алгоритм поиска обратной матрицы на нескольких узлах}
        \label{alg:inv_pl_matrix}
        \begin{algorithmic}[1]
            \Procedure{invert\_matrix}{$matrix$, $invert\_matrix$, $matrix\_length$, $rank$, $size$, $matrix\_rows$}

                \State Распределить матрицу $matrix$ по узлам в $matrix\_r$
                \State Создать нулевую матрицу $inv\_matrix$ размером $matrix\_length \times matrix\_rows$

                \For {$i \gets 0$ to $matrix\_rows - 1$}
                    \State $(\&inv\_matrix[i][i \times size + rank] \gets 1$
                \EndFor


                \For {$i$ от $0$ до $matrix\_length - 1$}
                    \Comment Прямой ход

                    \If {$i \% size = rank$}
                        \Comment Проверка принадлежности узлу

                        \State $pivot \gets row[i]$
                        \State Умножить строку $matrix\_r[i / size]$ на $1/pivot$
                        \State Умножить строку $inv\_matrix[i / size]$ на $1/pivot$

                        \State Разослать всем строки $matrix\_r[i / size]$ , $inv\_matrix[i / size]$
                    \EndIf

                    \State Получить строки с индексом i в $row, irow$

                    \For{$j$ от $0$ до $i / size$}
                        \State $mul \gets row[i]$

                        \State Добавить к $matrix\_r[j]$ строку $row$, умноженную на $-mul$
                        \State Добавить к $inv\_matrix[j]$ строку $irow$, умноженную на $-mul$
                    \EndFor
                \EndFor

                \For{$i$ от $matrixsize-1$ до $1$ с шагом $-1$}
                    \Comment Обратный ход

                    \If {$i \% size = rank$}
                        \Comment Проверка принадлежности узлу
                        \State Разослать всем строки $matrix\_r[i / size]$ , $inv\_matrix[i / size]$
                    \EndIf

                    \State Получить строки с индексом $i$ в $row, irow$


                    \For{$j$ от $0$ до $i / size$}
                        \State $mul \gets row[i]$

                        \State Добавить к $matrix\_r[j]$ строку $row$, умноженную на $-mul$
                        \State Добавить к $inv\_matrix[j]$ строку $irow$, умноженную на $-mul$
                    \EndFor
                \EndFor


                \State Собрать с узлов $inv\_matrix$ в матрицу $invert\_matrix$

            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
\end{small}


\section*{Вывод}

В разделе описан разработанный последовательный алгоритм поиска обратной матрицы, а также распределённый алгоритм поиска обратной матрицы на нескольких узлах. Распределённый алгоритм учитывает сложности разработки параллельного алгоритма и направлен на их преодоление.

Основные сложности разработки параллельного алгоритма включают разбиение исходной матрицы между процессами, метод Гаусса, требующий обмена данными между процессами, и необходимость синхронизации работы всех процессов после каждого шага алгоритма для корректного выполнения метода.

Для распределения данных между узлами предлагается использовать циклическую рассылку строк матрицы вычислительным узлам, чтобы каждая строка была обработана ровно одним узлом и каждый узел получил равное количество строк для обработки.

Распределённый алгоритм поиска обратной матрицы включает распределение матрицы по узлам, создание нулевой матрицы, прямой ход, обратный ход, сборку матрицы с узлов. Такой подход позволяет равномерно загрузить узлы, минимизировать коммуникации и эффективно использовать вычислительные ресурсы.